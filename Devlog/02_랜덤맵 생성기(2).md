# 랜덤맵 생성기(2)

URL: https://velog.io/@woolucy/UE5-%EA%B3%B5%ED%8F%AC%EA%B2%8C%EC%9E%84-MIZI-%EA%B0%9C%EB%B0%9C-%EC%9D%BC%EC%A7%80-2-%EB%9E%9C%EB%8D%A4%EB%A7%B5-%EC%83%9D%EC%84%B1%EA%B8%B02
업로드일: 2024년 12월 4일
주제: Level Design

# 서두

오늘은 앞서 만들었던 랜덤맵 생성기 블루프린트를 C++로 포팅하는 과정을 작성할 것이다.

# Master Room

## AMasterRoom

마스터룸부터 만들었던 블루프린트와 동일하게, C++ 역시 마스터룸을 만들면서 시작해본다. 랜덤맵 생성에 쓰일 모든 방들은 이 마스터룸을 상속받을 것이다. 블루프린트를 참고해서 사용될 컴포넌트와 변수들을 헤더에서 선언한다.

![image.png](image.png)

```cpp
UCLASS()
class MIZI_API AMasterRoom : public AActor
{
	GENERATED_BODY()
	
public:	
	AMasterRoom();

protected:
	virtual void BeginPlay() override;

public:	
	virtual void Tick(float DeltaTime) override;

public:
	UPROPERTY(VisibleAnywhere)
	USceneComponent* DefaultSceneRoot = nullptr;

	UPROPERTY(VisibleAnywhere)
	USceneComponent* OverlapFolder = nullptr;

	UPROPERTY(VisibleAnywhere)
	USceneComponent* ExitsFolder = nullptr;

	UPROPERTY(VisibleAnywhere)
	USceneComponent* GeometryFolder = nullptr;

protected:
	UPROPERTY(EditAnywhere)
	TObjectPtr<UArrowComponent> Arrow;

	UPROPERTY(EditAnywhere)
	TObjectPtr<UBoxComponent> OverlapBox;
};
```

화살표 컴포넌트와 충돌 박스의 경우, 블루프린트 에디터에서도 수정 가능해야하기 때문에 프로퍼티를 EditAnywhere로 해주어야한다.

프로젝트를 거의 완성한 현재 시점에서 다시 보니, 원시 포인터와 TObjectPtr를 혼용하고 있다.이유는 모르겠지만 에픽 게임즈가 TObjectPtr를 쓰라고 하니, 나중에 일괄적으로 TObjectPtr로 바꾸는 시간을 가져야겠다.

참고: https://dev.epicgames.com/documentation/ko-kr/unreal-engine/unreal-engine-5-migration-guide#c++%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%ED%8F%AC%EC%9D%B8%ED%84%B0%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0

### AMasterRoom::AMasterRoom()

헤더 상에서 컴포넌트의 계층 구조를 따로 만들어줄 수 없기 때문에 생성자 내부에서 각 폴더의 계층구조를 만들어준다.

```cpp
AMasterRoom::AMasterRoom()
{
	PrimaryActorTick.bCanEverTick = true;

	// DefaultSceneRoot
	//	Arrow
	//	GeometryFolder
	//	OverlapFolder
	//		OverlapBox
	//	ExitsFolder

	DefaultSceneRoot = CreateDefaultSubobject<USceneComponent>(TEXT("DefaultSceneRoot"));
	RootComponent = DefaultSceneRoot;

	Arrow = CreateDefaultSubobject<UArrowComponent>(TEXT("Arrow"));
	Arrow->SetupAttachment(RootComponent);
	Arrow->ArrowColor = FColor::Red;
	Arrow->ArrowSize = 8.f;
	Arrow->SetRelativeLocation(FVector(760.0, 0.0, 290.0));
	Arrow->SetHiddenInGame(false);

	GeometryFolder = CreateDefaultSubobject<USceneComponent>(TEXT("GeometryFolder"));
	GeometryFolder->SetupAttachment(RootComponent);

	OverlapFolder = CreateDefaultSubobject<USceneComponent>(TEXT("OverlapFolder"));
	OverlapFolder->SetupAttachment(RootComponent);

	OverlapBox = CreateDefaultSubobject<UBoxComponent>(TEXT("OverlapBox"));
	OverlapBox->SetupAttachment(OverlapFolder);
	
	if(OverlapBox)
	{
		OverlapBox->SetCollisionProfileName(TEXT("Room"));
	}

	ExitsFolder = CreateDefaultSubobject<USceneComponent>(TEXT("ExitsFolder"));
	ExitsFolder->SetupAttachment(RootComponent);
}
```

`SetupAttachment()` 를 사용해서 컴포넌트의 계층 구조를 만들어주었다.

## Room

이렇게 만든 MasterRoom를 상속받아 에디터에서 룸 프리셋을 만들어주었다. 

![image.png](image%201.png)

![image.png](image%202.png)

컴포넌트 역시 설계한대로 계층 구조를 잘 가지고 있음을 확인할 수 있다.

이들은 생성기가 제대로 작동하는지 확인하기 위한 임시 Room이기 때문에, 따로 꾸미지는 않고 화살표의 위치만 유의해서 빠르게 만들었다.

# Random Map Generator Data

블루프린트에서는 그냥 내부 변수로 사용되는 방 종류와 개수를 정해주었지만, C++에서는 데이터 에셋을 사용할 것이다.

에디터에서 랜덤맵 생성기 데이터 에셋을 작성하면, 그 정보에 맞춰 생성기가 랜덤맵을 구성할 것이다.

블루프린트를 참고해서 랜덤맵 생성에 필요한 정보를 대략 정리해보았다.

![image.png](image%203.png)

- Seed: 스트림에 사용할 시드.
- Max Room Amount: 생성기가 만들 방의 개수
- Max Dungeon Time: 랜덤맵 생성 시간의 상한선
- Start Room Class: 맨 처음 스폰될 방의 클래스
- Room List: 랜덤으로 선택될 방의 클래스 종류 목록
- Wall Class: 벽의 클래스

이를 코드로 표현하면 다음과 같다.

```cpp
UCLASS()
class MIZI_API URandomMapGeneratorDataAsset : public UDataAsset
{
	GENERATED_BODY()

public:
	UPROPERTY(EditAnywhere, Category = "RandomMap")
	int32 Seed = -1;

	UPROPERTY(EditAnywhere, Category = "RandomMap")
	uint32 MaxRoomAmount = 10;

	UPROPERTY(EditAnywhere, Category = "RandomMap")
	float MaxDungeonTime;

	UPROPERTY(EditAnywhere, Category = "RandomMap")
	TSubclassOf<AMasterRoom> StartRoomClass;

	UPROPERTY(EditAnywhere, Category = "RandomMap")
	TArray<TSubclassOf<AMasterRoom>> RoomList;

	UPROPERTY(EditAnywhere, Category = "RandomMap")
	TSubclassOf<AEndWall> WallClass;
};
```

따로 헤더 파일을 만들지 않고, RandomMapGenerator.h에 바로 구현해두었다.

따로 include 안 해도 되고 오히려 좋아. 어차피 다른 클래스에서 안 쓸거잖아?

`SpawnActor()`를 사용할 때, 스폰할 액터의 클래스를 요구하기 때문에 `TSubclassOf`를 써서 방 클래스를 저장한다. 또한, 데이터 에셋은 에디터에서 편집할 것이기 때문에 프로퍼티를 EditAnywhere로 설정해주었다.

![image.png](image%204.png)

그렇게 만들어진 랜덤맵 생성기 데이터 에셋이다. 

랜덤맵 생성기는 이 데이터 에셋의 각 정보를 읽어와서 새로운 방을 생성할 것이다.

# Random Map Generator

![image.png](image%205.png)

랜덤맵 생성기 역시 블루프린트를 참고해 필요한 컴포넌트와 변수들을 헤더에서 선언한다.

```cpp
UCLASS()
class MIZI_API ARandomMapGenerator : public AActor
{
	GENERATED_BODY()
	
public:	
	ARandomMapGenerator();

protected:
	virtual void BeginPlay() override;

public:	
	virtual void Tick(float DeltaTime) override;
	
protected:
	UPROPERTY(VisibleAnywhere)
	USceneComponent* DefaultSceneRoot = nullptr;
	
	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<USceneComponent*> ExitsList;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<USceneComponent> SelectedExitPoint;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TObjectPtr<AMasterRoom> LatestRoom;

	UPROPERTY(EditAnywhere)
	class URandomMapGeneratorDataAsset* RandomMapGeneratorDataAsset;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	TArray<UPrimitiveComponent*> OverlappedList;

	UPROPERTY(EditAnywhere, BlueprintReadWrite)
	FRandomStream Stream;

	
private:
	uint32 CurRoomAmount;
	bool bRandomMapComplete = false;

	FTimerHandle RandomMapTimerHandle;
}
```

C++ 구현 도중에 기능을 확인하려고 블루프린트에서 불러 수정했기 때문에 프로퍼티가 EditAnywhere, BlueprintReadWrite이다.

앞서 만들어두었던 데이터 에셋도 필요하기 때문에 포인터로 가지고 있다.

```cpp
UCLASS()
class MIZI_API ARandomMapGenerator : public AActor
{
...
protected:
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void SpawnStartRoom();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void StartRandomMapTimer();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void CheckToRandomMapComplete();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void SpawnNextRoom();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void CheckForOverlap();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void AddOverlappingRoomsToList();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void CloseHoles();
	UFUNCTION(BlueprintCallable, Category = "RandomMap")
	void SetSeed();
	
	uint32 GetRoomAmount() { return CurRoomAmount; };
	void SetRoomAmount(uint32 _InAmount) { CurRoomAmount = _InAmount; }

	bool GetDungeonComplete() { return bRandomMapComplete; }
	void SetDungeonComplete(bool _InBool) { bRandomMapComplete = _InBool; 
...
};
```

블루프린트를 참고해서 필요한 함수들도 미리 선언해준다. 이 함수들 역시 중간중간 블루프린트에서 실험했기 때문에 UFUNCTION으로 선언했고 프로퍼티도 BlueprintCallable이다. 또한 방의 총 개수와 생성 성공 여부는 외부에서도 추후에 필요할 것 같아서 겟터와 셋터를 구현해두었다.

이제 본격적으로 함수를 정의해 구현을 시작하면 된다.

## ARandomMapGenerator()

```cpp
ARandomMapGenerator::ARandomMapGenerator()
{
	  PrimaryActorTick.bCanEverTick = true;
	  
		// 컴포넌트 초기화
    DefaultSceneRoot = CreateDefaultSubobject<USceneComponent>(TEXT("DefaultSceneRoot"));
    RootComponent = DefaultSceneRoot;

		// 시작 방 클래스 로드
    static ConstructorHelpers::FClassFinder<AActor> ActorBlueprint(TEXT("/Script/Engine.Blueprint'/Game/RandomMap/StartRoom.StartRoom_C'"));
    if (ActorBlueprint.Succeeded())
    {
        StartRoomClass = ActorBlueprint.Class;
    }

		// 데이터 에셋 로드
    static ConstructorHelpers::FObjectFinder<URandomMapGeneratorDataAsset> DataFinder(TEXT("/Script/MIZI.RandomMapGeneratorDataAsset'/Game/RandomMap/DA_RandomMapGenerator.DA_RandomMapGenerator'"));
    if (DataFinder.Succeeded())
    {
        RandomMapGeneratorDataAsset = DataFinder.Object;
    }
    
    Stream.Initialize(RandomMapGeneratorDataAsset->Seed);

}
```

`ConstructorHelpers` 를 사용해서 데이터 에셋을 `RandomMapGeneratorDataAsset` 에 로드했다. 

## BeginPlay()

```cpp
void ARandomMapGenerator::BeginPlay()
{
    Super::BeginPlay();

    SetRoomAmount(RandomMapGeneratorDataAsset->MaxRoomAmount);

    SetSeed();
    SpawnStartRoom();
    StartRandomMapTimer();
    SpawnNextRoom();
}
```

플레이가 시작되면 다음 로직을 따른다.

- Set Room Amount: 데이터 에셋에서 정보를 불러와 최대 방 개수를 설정
- Set Seed: 생성에 사용할 시드를 정함
- Start Random Map Timer: 타이머를 재생 시작. 타이머 완료까지 생성이 끝나지 않는다면 레벨 재오픈
- Spawn Next Room: 다음 방을 생성. 최대 방 개수가 될 때까지 재귀 호출

## SetSeed()

```cpp
void ARandomMapGenerator::SetSeed()
{
    if (RandomMapGeneratorDataAsset->Seed == -1)
    {
        UKismetMathLibrary::SeedRandomStream(Stream);
    }
    else
    {
        UKismetMathLibrary::SetRandomStreamSeed(Stream, RandomMapGeneratorDataAsset->Seed);
    }
}
```

데이터 에셋에서 설정된 시드가 -1이면 랜덤 스트림을 사용해 방을 생성한다. 플레이가 시작될 때마다 매번 다른 방 구조가 생성된다는 의미이다.

-1이 아니라면 고정된 수가 시드로 들어간다. 플레이가 시작될 때마다 정해진 시드에 맞는 방 구조가 생성된다는 뜻이다.

`SetRandomStreamSeed()` 을 사용해서 시드 시스템을 구현했다.

## SpawnStartRoom()

```cpp
void ARandomMapGenerator::SpawnStartRoom()
{
    if (UWorld* World = GetWorld())
    {
        FTransform RootTransform = DefaultSceneRoot->K2_GetComponentToWorld();
        FActorSpawnParameters SpawnParams;
        SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

        AActor* SpawnedActor = World->SpawnActor<AActor>(RandomMapGeneratorDataAsset->StartRoomClass, RootTransform, SpawnParams);

        AMasterRoom* SpawnedRoom = Cast<AMasterRoom>(SpawnedActor);
        TArray<USceneComponent*> OutChildren;
        SpawnedRoom->ExitsFolder->GetChildrenComponents(false, OutChildren);

        ExitsList.Append(OutChildren);
    }
}
```

데이터 에셋에서 필요한 클래스를 로드해 와 시작 방을 스폰한다. 블루프린트와 동일하게 `ESpawnActorCollisionHandlingMethod::AlwaysSpawn` 로 설정해두어야 정상적으로 작동한다.

스폰된 방의 ExitsFolder에 접근해 출구 리스트를 얻은 뒤 이들을 랜덤 맵 생성기의 출구 리스트에 추가한다. add와 달리 append는 다수의 요소를 한번에 추가할 수 있어, 방의 출구가 여러개인 이 상황에 적절하다.

## StartRandomMapTimer

```cpp
void ARandomMapGenerator::StartRandomMapTimer()
{
    GetWorld()->GetTimerManager().SetTimer(
        RandomMapTimerHandle,
        this,
        &ARandomMapGenerator::CheckToRandomMapComplete,
        1.0f,
        true
    );
}

void ARandomMapGenerator::CheckToRandomMapComplete()
{
    UE_LOG(LogTemp, Warning, TEXT("Running"));

    float TimeSeconds = GetWorld()->GetTimeSeconds();
    if (TimeSeconds >= RandomMapGeneratorDataAsset->MaxDungeonTime)
    {
        FString CurrentLevelName = GetWorld()->GetMapName();
        CurrentLevelName.RemoveFromStart(GetWorld()->StreamingLevelsPrefix);
        UGameplayStatics::OpenLevel(GetWorld(), FName(*CurrentLevelName));
    }
}
```

타이머를 사용해서 맵이 생성되는 동안 Running 문구를 로그로 찍는다. 또한, 타이머가 시작된 이후로 데이터 에셋의 생성 시간 상한선을 넘었는지 확인한다. 상한선을 넘겼다면, `OpenLevel()`로 현재 레벨을 다시 열어 맵을 처음부터 다시 생성하게 만든다.

## SpawnNextRoom()

```cpp
void ARandomMapGenerator::SpawnNextRoom()
{
    if (UWorld* World = GetWorld())
    {
        SelectedExitPoint = FUtils::RandomArrayItemFromStream(ExitsList, Stream);

        FTransform SelectedTransform = SelectedExitPoint->K2_GetComponentToWorld();
        FActorSpawnParameters SpawnParams;
        SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

        TSubclassOf<AMasterRoom> RoomClass = FUtils::RandomArrayItemFromStream(RandomMapGeneratorDataAsset->RoomList, Stream);

        AActor* SpawnedActor = World->SpawnActor<AActor>(RoomClass, SelectedTransform, SpawnParams);
        LatestRoom = Cast<AMasterRoom>(SpawnedActor);

        UKismetSystemLibrary::K2_SetTimer(this, TEXT("CheckForOverlap"), 0.1f, false);
    }
}

```

`RandomArrayItemFromStream()`을 사용해서 출구 리스트에서 랜덤한 위치를 뽑고, 데이터 에셋의 방 리스트에서 랜덤한 방 클래스를 뽑아와 스폰한다.

새로 생성된 방이 예전에 이미 생성된 방과 겹치는지 확인하는 과정이 필요하다. 이 과정은 `CheckForOverlap()` 에서 수행된다.

## CheckForOverlap()

일단 이미 생성된 방과 겹치는지 확인하려면, 이미 생성된 방들의 리스트가 필요하다.

```cpp
void ARandomMapGenerator::AddOverlappingRoomsToList()
{
    TArray<USceneComponent*> OutChildren;
    LatestRoom->OverlapFolder->GetChildrenComponents(false, OutChildren);

    for (USceneComponent* Child : OutChildren)
    {
        UBoxComponent* ChildBox = Cast<UBoxComponent>(Child);
        if (ChildBox)
        {
            TArray<UPrimitiveComponent*> OutOverlappingComponents;
            ChildBox->GetOverlappingComponents(OutOverlappingComponents);

            OverlappedList.Append(OutOverlappingComponents);
        }
    }
}
```

`AddOverlappingRoomsToList()`가 하는 일은 단순하다. 가장 최근 추가된(스폰된) 방에 다른 액터와 겹쳐진 컴포넌트들을 죄다 Overlapped List에 넣는 일을 한다. 

이 함수 실행 이후 Overlapped List가 비어있지 않다면, 방금 만든 방이 다른 방과 겹친다는 의미일 것이다.

이후의 과정은 다시 `CheckForOverlap()`에서 수행한다.

```cpp
void ARandomMapGenerator::CheckForOverlap()
{
    AddOverlappingRoomsToList();
    
		...
		
    if (!OverlappedList.IsEmpty())
    {
        OverlappedList.Empty();
        LatestRoom->Destroy();
        SpawnNextRoom();
    }
    
    ...
}
```

OverlappedList가 비지 않았다면, 이미 생성된 방과 새로 생성된 방이 겹쳤다는 의미이다. 따라서, OverlappedList를 비우고 새로 생성된 방을 삭제한다. 이후, `SpawnNextRoom()` 를 호출해 생성 로직을 다시 시작한다.

```cpp
void ARandomMapGenerator::CheckForOverlap()
{
    ...
    else
    {
        OverlappedList.Empty();
        uint32 NewRoomAmount = GetRoomAmount() - 1;
        SetRoomAmount(NewRoomAmount);

        ExitsList.Remove(SelectedExitPoint);

        TArray<USceneComponent*> OutChildren;
        LatestRoom->ExitsFolder->GetChildrenComponents(false, OutChildren);
        ExitsList.Append(OutChildren);

        if (GetRoomAmount() > 0)
        {
            SpawnNextRoom();
        }
        ...
    }
}
```

OverlappedList가 비었다면 겹치지 않는 위치에 성공적으로 방이 스폰되었다는 의미이다.

스폰에 성공했으면 스폰될 방의 개수를 하나 줄인다. 또 선택된 출구의 위치를 출구 목록에서 제외한다. 생성된 방의 출구 목록을 생성기에 출구 리스트에 추가해 다음 방 생성을 준비한다. 

만약, 생성해야 할 방의 개수가 남았다면 `SpawnNextRoom()`를 호출해 다음 방을 생성한다.

```cpp
    else
    {
        ...
        if (GetRoomAmount() > 0)
        ...
        else
        {
            UKismetSystemLibrary::K2_SetTimer(this, TEXT("CloseHoles"), 1.f, false);
            SetDungeonComplete(true);

            GetWorld()->GetTimerManager().ClearTimer(RandomMapTimerHandle);
            UE_LOG(LogTemp, Warning, TEXT("Dungeon Complete"));

            UWorld* World = GetWorld();
            if (!World)
            {
                UE_LOG(LogTemp, Warning, TEXT("World is not valid."));
                return;
            }
        }
    }
    
void ARandomMapGenerator::CloseHoles()
{
    for (USceneComponent* Exit : ExitsList)
    {
        if (UWorld* World = GetWorld())
        {
            FTransform SelectedTransform = Exit->K2_GetComponentToWorld();
            FActorSpawnParameters SpawnParams;
            SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

            AActor* SpawnedActor = World->SpawnActor<AActor>(RandomMapGeneratorDataAsset->WallClass, SelectedTransform, SpawnParams);
        }
    }
}
```

생성해야할 방의 개수가 더 이상 남지 않았다면 랜덤맵 생성은 마무리에 들어간다. 일단, 맵 생성이 성공적으로 완료되었다는 플래그를 설정하고 타이머를 종료한다.

이후, `CloseHoles()`를 호출해서 뚫린 벽을 막는다. 데이터 에셋에서 설정해둔 벽 클래스를 불러와 출구 목록의 모든 출구들의 위치에 벽을 스폰한다.

벽까지 막았다면, 랜덤맵 생성은 성공적으로 끝났다.

# 결과

![MIZI [DebugGame] - Unreal Editor 2024-12-04 16-13-08.gif](MIZI_DebugGame_-_Unreal_Editor_2024-12-04_16-13-08.gif)

시드를 -1로 넣으면 매번 다른 맵이 랜덤하게 생성되는 것을 확인할 수 있다.

[https://youtu.be/Fd7h32u95e0](https://youtu.be/Fd7h32u95e0)

# 발생했던 문제

## 방과 방이 겹침

![image.png](92e596cb-abba-46bd-841a-e3f68c5171e1.png)

이런 식으로 외관 상으로는 괜찮아 보이지만, 아웃라이너에서 확인해보면 방 여러개가 겹쳐져 있는 상황을 발견했다.

![image.png](image%206.png)

![image.png](image%207.png)

MasterRoom의 OveralppingBox의 콜리전 프로파일이 디폴트값으로 BlockAllDynamic으로 되어있었기 때문에 발생한 일이었다. 왜냐하면 BlockAllDynamic의 경우 Room Overlap 채널에 대해 무조건 무시하기 때문이다. 마스터룸의 충돌 박스는 현재 다른 방과 위치가 겹치는지 확인하는 역할인데, 이를 제대로 수행하지 못하게 된다는 뜻이다.

```cpp
	if(OverlapBox)
	{
		OverlapBox->SetCollisionProfileName(TEXT("Room"));
	}
```

생성자에서 충돌 박스의 콜리전 프로파일을 Room으로 바꿔 해결할 수 있다.